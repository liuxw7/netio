#pragma once
#include <stdint.h>


#include "Dispatcher.hpp"
#include "Endian.hpp"

namespace netio {

// specify protocol for payload content, for compatibility, this number can't be changed.
typedef enum {
  FLNPProto_UNKNOWN = 0,
  FLNPProto_PROTOBUF = 1,
  FLNPProto_JSON = 2
} FLNPProto;


// this struct is used to descript peer message info for field length netpack wrapper.
struct PeerMessage : public Message<int> {
  PeerMessage() {}
  
  PeerMessage(int cmd, SpVecBuffer& buffer) :
      Message<int>(cmd, buffer),
      _proto(FLNPProto_UNKNOWN),      
      _seq(-1),
      _version(-1)
  {}

  PeerMessage(int cmd, SpVecBuffer& buffer, FLNPProto proto, int16_t seq, int8_t version) :
      Message<int>(cmd, buffer),
      _proto(proto),
      _seq(seq),
      _version(version)
  {}

  FLNPProto _proto;
  int8_t _version;   // version for logical protocol.
  int16_t _seq;       // sequence number, generated by sender.
};

typedef shared_ptr<struct PeerMessage> SpPeerMessage;

#pragma pack(push)
#pragma pack(1)
// payload header for field length netpack
struct FLNPHeader {
  /** 
   * peek packet length, include header from raw memory pointer.
   * 
   * @param bufptr 
   * @param buflen 
   * 
   * @return 
   */
  static ssize_t peekPacketLength(const void* bufptr, size_t buflen) {
    if((buflen > sizeof(_len)) && (nullptr != bufptr)) {
      return Endian::ntoh16(*(static_cast<const uint16_t*>(bufptr)));
    }
    return -1;
  }

  /** 
   * peek packet length, include header, from vecbuffer.
   * 
   * @param buffer 
   * 
   * @return 
   */
  static ssize_t peekPacketLength(const SpVecBuffer& buffer) {
    if(buffer->readableSize() >= sizeof(_len)) {
      return static_cast<size_t>(buffer->peekInt16());      
    }
    return -1;
  }

  /** 
   * Encode netpack header by detail parameters to raw memory pointer.
   * 
   * @param conlen 
   * @param proto 
   * @param version 
   * @param seq 
   * @param cmd 
   * @param bufptr 
   * @param buflen 
   */
  static void encode(uint16_t conlen, uint8_t proto, uint8_t version, uint16_t seq, uint32_t cmd,
                     void* bufptr, size_t buflen) {
    ASSERT((nullptr != bufptr) && (buflen >= sizeof(struct FLNPHeader)));
    
    FLNPHeader* header = static_cast<struct FLNPHeader*>(bufptr);
    header->_len = Endian::hton16(conlen + sizeof(struct FLNPHeader));
    header->_proto = proto;
    header->_ver = version;
    header->_seq = Endian::hton16(seq);
    header->_reserv = 0;
    header->_cmd = Endian::hton32(cmd);
  }

  /** 
   * encode netpack header by detail parameters to VecBuffer.
   * 
   * @param conlen 
   * @param proto 
   * @param version 
   * @param seq 
   * @param cmd 
   * @param buffer 
   */
  static void encode(uint16_t conlen, uint8_t proto, uint8_t version, uint16_t seq, uint32_t cmd,
                     SpVecBuffer& buffer) {
    encode(conlen, proto, version, seq, cmd, buffer->writtablePtr(), buffer->writtableSize());
  }

  /** 
   * encode peer message information to netpack header
   * 
   * @param pm 
   * @param buffer 
   */
  static void encode(struct PeerMessage& pm, SpVecBuffer& buffer) {
    encode(pm._buffer->readableSize(),
           static_cast<uint8_t>(pm._proto),
           pm._version,
           pm._seq,
           pm._cmd,
           buffer->writtablePtr(),
           buffer->writtableSize());

    buffer->markWrite(sizeof(struct FLNPHeader));
  }


  static void decode(SpVecBuffer& buffer, SpPeerMessage& pm) {
    ASSERT(buffer->readableSize() > sizeof(struct FLNPHeader));

    const struct FLNPHeader* header = static_cast<const struct FLNPHeader*>((void*)buffer->readablePtr());
    buffer->markRead(sizeof(struct FLNPHeader));
    
    pm->_cmd = Endian::ntoh32(header->_cmd);
    pm->_seq = Endian::ntoh16(header->_seq);
    pm->_proto = static_cast<FLNPProto>(header->_proto);
    pm->_version = header->_ver;
    pm->_buffer = buffer;
  }

  uint16_t _len;     // total len, including header, put this in the begining of payload.
  uint8_t _proto;    // FLNPProto
  uint8_t _ver;      // which protocol and version to decode the packet content.
  uint16_t _seq;     // sequence number of the packet
  uint16_t _reserv;  // reservb 
  uint32_t _cmd;     // command id
};
#pragma pack(pop)

static_assert(sizeof(struct FLNPHeader) == 12, "sizeof GenericLenFieldHeader NOT expect length");

class FLNPack {
 public:
  typedef PeerMessage MsgType;
  //  readMessage and peekPackLength.

  /** 
   * peek packet total length from vecbuffer.
   * 
   * @param buffer 
   * 
   * @return 
   */
  static ssize_t peekPackLength(const SpVecBuffer& buffer) {
    return FLNPHeader::peekPacketLength(buffer);
  }
  
  /** 
   * create peer message from vecbuffer.
   * 
   * @param buffer 
   * 
   * @return 
   */
  static SpPeerMessage readMessage(SpVecBuffer& buffer) {
    ssize_t packSize = FLNPHeader::peekPacketLength(buffer);

    if(LIKELY(packSize > 0)) {
      SpVecBuffer splited = buffer->split(static_cast<size_t>(packSize));
      if(nullptr != splited) {
        SpPeerMessage spMsg(new PeerMessage);
        FLNPHeader::decode(splited, spMsg);
        return spMsg;
      }
    }

    return nullptr;
  }

  /** 
   * Create netpack buffer. the buffer has no encoded header.
   * 
   * @param conlen 
   * 
   * @return 
   */
  static SpVecBuffer createNetPackBuffer(size_t conlen) {
    return SpVecBuffer(new VecBuffer(sizeof(struct FLNPHeader) + conlen));
  }

  /** 
   * Create netpack buffer and write netpack header information. After buffer created, we get writtable ptr and
   * write buffer to perform zero copy pack operation.
   * 
   * @param conlen 
   * @param proto 
   * @param version 
   * @param seq 
   * @param cmd 
   * 
   * @return 
   */
  static SpVecBuffer createNetPackBuffer(uint16_t conlen, uint8_t proto, uint8_t version, uint16_t seq, uint32_t cmd) {
    SpVecBuffer buffer = createNetPackBuffer(conlen);
    FLNPHeader::encode(conlen, proto, version, seq, cmd, buffer);
    return buffer;
  }

  /** 
   * Create netpack buffer, encode netpack header and copy content.
   * NOTICE : This will call memcpy.
   * 
   * @param peerMsg 
   * 
   * @return 
   */
  static SpVecBuffer writeMessage(const struct PeerMessage& peerMsg) {
    size_t conlen = peerMsg._buffer->readableSize();
    SpVecBuffer buffer = createNetPackBuffer(conlen, static_cast<uint8_t>(peerMsg._proto), peerMsg._version, peerMsg._seq, peerMsg._cmd);
    if(LIKELY((nullptr != peerMsg._buffer) && (peerMsg._buffer->readableSize() > 0))) {
      ::memcpy(buffer->writtablePtr(), peerMsg._buffer->readablePtr(), peerMsg._buffer->readableSize());
      buffer->markWrite(peerMsg._buffer->readableSize());
    }

    return buffer;
  }

  /** 
   * Create netpack buffer, encode netpack header and copy content.
   * NOTICE : This will call memcpy.
   * 
   * @param proto 
   * @param version 
   * @param seq 
   * @param cmd 
   * @param conptr : content buffer address
   * @param conlen : content length
   * 
   * @return 
   */
  static SpVecBuffer writeMessage(uint8_t proto, uint8_t version, uint16_t seq, uint32_t cmd,
                                         void* conptr, size_t conlen) {
    ASSERT(nullptr != conptr);
    SpVecBuffer buffer = createNetPackBuffer(conlen, proto, version, seq, cmd);

    if(LIKELY(conlen > 0)) {
      ::memcpy(buffer->writtablePtr(), conptr, conlen);
      buffer->markWrite(conlen);
    }
    return buffer;
  }

  
};

}



